<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon City: Undead Rising RPG</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
        }

        /* HUD Layers */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* Crosshair */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .crosshair-line {
            position: absolute;
            background: lime;
        }

        .h-line {
            width: 100%;
            height: 2px;
            top: 9px;
        }

        .v-line {
            height: 100%;
            width: 2px;
            left: 9px;
        }

        /* Stats HUD */
        #stats-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            text-shadow: 1px 1px 0 #000;
            font-size: 18px;
            line-height: 1.5;
        }

        .stat-box {
            display: flex;
            gap: 15px;
        }

        .stat-value {
            font-weight: bold;
            color: #0ff;
        }

        .hp-bar-bg {
            width: 200px;
            height: 15px;
            background: #333;
            border: 1px solid #fff;
            margin-top: 5px;
        }

        .hp-bar-fill {
            height: 100%;
            background: #f00;
            width: 100%;
            transition: width 0.2s;
        }

        .exp-bar-bg {
            width: 200px;
            height: 8px;
            background: #333;
            border: 1px solid #888;
            margin-top: 5px;
        }

        .exp-bar-fill {
            height: 100%;
            background: #fd0;
            width: 0%;
            transition: width 0.2s;
        }

        /* Wave Info */
        #wave-panel {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #f00;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
        }

        /* Interaction Hints */
        #hint-panel {
            position: absolute;
            bottom: 100px;
            right: 20px;
            text-align: right;
            color: #ccc;
            font-size: 14px;
        }

        /* Menus (Shop/Skills/Pause) */
        .modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #0ff;
            padding: 20px;
            color: white;
            width: 600px;
            text-align: center;
            pointer-events: auto;
            border-radius: 10px;
            box-shadow: 0 0 20px #0ff;
        }

        .modal h2 {
            margin-top: 0;
            color: #0ff;
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
        }

        .modal-content {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            gap: 10px;
            margin: 20px 0;
        }

        .btn {
            background: #222;
            color: #fff;
            border: 1px solid #555;
            padding: 10px 20px;
            cursor: pointer;
            font-family: inherit;
            transition: 0.2s;
            width: 45%;
        }

        .btn:hover {
            background: #444;
            border-color: #fff;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-green {
            border-color: lime;
            color: lime;
        }

        .btn-gold {
            border-color: gold;
            color: gold;
        }

        /* Start Screen */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            pointer-events: auto;
        }

        h1 {
            font-size: 60px;
            color: #f00;
            text-shadow: 0 0 10px #f00;
            margin: 0;
        }

        .start-btn {
            font-size: 24px;
            padding: 15px 40px;
            margin-top: 20px;
            cursor: pointer;
            background: #f00;
            color: white;
            border: none;
            font-weight: bold;
        }

        /* Damage Overlay */
        #damage-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 50%, rgba(255, 0, 0, 0.5) 100%);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .notification {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            color: gold;
            font-size: 24px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 1s;
            text-shadow: 1px 1px 0 #000;
        }
    </style>
</head>

<body>

    <!-- 3D Canvas Container -->
    <div id="canvas-container"></div>

    <!-- UI Overlay -->
    <div id="damage-overlay"></div>
    <div id="ui-layer">
        <div id="crosshair">
            <div class="crosshair-line h-line"></div>
            <div class="crosshair-line v-line"></div>
        </div>

        <div id="wave-panel">WAVE 1</div>

        <div id="stats-panel">
            <div class="stat-box">
                <div>LVL <span id="hud-level" class="stat-value">1</span></div>
                <div>GOLD <span id="hud-gold" class="stat-value" style="color:gold;">0</span></div>
                <div>SKILL PTS <span id="hud-sp" class="stat-value" style="color:lime;">0</span></div>
            </div>
            <div class="hp-bar-bg">
                <div id="hud-hp-fill" class="hp-bar-fill"></div>
            </div>
            <div style="font-size: 14px; margin-top: 2px;">HP: <span id="hud-hp-text">100/100</span></div>
            <div class="exp-bar-bg">
                <div id="hud-exp-fill" class="exp-bar-fill"></div>
            </div>
            <div style="margin-top: 10px; font-size: 16px; color: #0ff;">
                WEAPON: <span id="hud-weapon">PISTOL</span><br>
                AMMO: <span id="hud-ammo">12/12</span><br>
                KILLS: <span id="hud-kills" style="color: #f00;">0</span>
            </div>
        </div>

        <div id="hint-panel">
            [WASD] Move &nbsp; [SPACE] Jump &nbsp; [L-Click] Shoot &nbsp; [R] Reload<br>
            [1-5] Switch Weapon &nbsp; [B] Shop &nbsp; [K] Skills &nbsp; [ESC] Pause
        </div>

        <div id="notification-area" class="notification">Level Up!</div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen">
        <h1>NEON CITY Z</h1>
        <p>Survive the waves. Upgrade your gear. Become the ultimate hunter.</p>
        <button class="start-btn" onclick="startGame()">ENTER CITY</button>
    </div>

    <!-- Shop Modal -->
    <div id="shop-modal" class="modal">
        <h2>WEAPON SHOP (Press B to Close)</h2>
        <div class="modal-content">
            <button class="btn btn-gold" id="btn-buy-potion" onclick="buyPotion()">
                Health Potion (50g)<br><small>Restore 50 HP</small>
            </button>
            <button class="btn btn-gold" id="btn-buy-ammo" onclick="buyAmmo()">
                Ammo Pack (30g)<br><small>Refill Current Weapon</small>
            </button>
            <button class="btn btn-gold" id="btn-buy-smg" onclick="buyWeapon('smg')">
                SMG (300g)<br><small>Fast Fire Rate</small>
            </button>
            <button class="btn btn-gold" id="btn-buy-shotgun" onclick="buyWeapon('shotgun')">
                Shotgun (500g)<br><small>Spread Damage</small>
            </button>
            <button class="btn btn-gold" id="btn-buy-sniper" onclick="buyWeapon('sniper')">
                Sniper (800g)<br><small>High Damage</small>
            </button>
            <button class="btn btn-gold" id="btn-buy-plasma" onclick="buyWeapon('plasma')">
                Plasma Rifle (1200g)<br><small>Piercing Shots</small>
            </button>
        </div>
        <p>Your Gold: <span id="shop-gold">0</span></p>
    </div>

    <!-- Skills Modal -->
    <div id="skill-modal" class="modal">
        <h2>SKILL TREE (Press K to Close)</h2>
        <div class="modal-content">
            <button class="btn btn-green" onclick="upgradeSkill('damage')">
                Damage +20%<br><small>Cost: 1 SP</small>
            </button>
            <button class="btn btn-green" onclick="upgradeSkill('health')">
                Max Health +20<br><small>Cost: 1 SP</small>
            </button>
            <button class="btn btn-green" onclick="upgradeSkill('speed')">
                Move Speed +5%<br><small>Cost: 1 SP</small>
            </button>
            <button class="btn btn-green" onclick="upgradeSkill('critChance')">
                Crit Chance +10%<br><small>Cost: 1 SP</small>
            </button>
            <button class="btn btn-green" onclick="upgradeSkill('dodge')">
                Dodge +8%<br><small>Cost: 1 SP</small>
            </button>
            <button class="btn btn-green" onclick="upgradeSkill('regen')">
                HP Regen +1/s<br><small>Cost: 1 SP</small>
            </button>
            <button class="btn btn-green" onclick="upgradeSkill('fireRate')">
                Fire Rate +15%<br><small>Cost: 1 SP</small>
            </button>
            <button class="btn btn-green" onclick="upgradeSkill('resistance')">
                Damage Resist +5%<br><small>Cost: 1 SP</small>
            </button>
            <button class="btn btn-green" onclick="upgradeSkill('xpBoost')">
                XP Gain +20%<br><small>Cost: 1 SP</small>
            </button>
            <button class="btn btn-green" onclick="upgradeSkill('ammoEfficiency')">
                Ammo Efficiency<br><small>Cost: 1 SP</small>
            </button>
        </div>
        <p>Available Points: <span id="skill-points">0</span></p>
    </div>

    <script>
        // --- GAME CONFIGURATION & STATE ---
        const CONFIG = {
            gravity: 30,
            playerSpeed: 15,
            playerJump: 15,
            colors: {
                sky: 0x050510,
                ground: 0x111111,
                building: 0x222222,
                buildingRim: 0x00ffff,
                zombie: 0x00ff00,
                bullet: 0xffff00
            }
        };

        // Weapon Definitions
        const WEAPONS = {
            pistol: { name: 'PISTOL', damage: 25, fireRate: 400, bulletSpeed: 40, bulletColor: 0xffff00, magazineSize: 12, reloadTime: 1.5, cost: 0, spread: 0, penetration: false },
            smg: { name: 'SMG', damage: 15, fireRate: 150, bulletSpeed: 45, bulletColor: 0xff6600, magazineSize: 30, reloadTime: 2.0, cost: 300, spread: 0.05, penetration: false },
            shotgun: { name: 'SHOTGUN', damage: 20, fireRate: 800, bulletSpeed: 35, bulletColor: 0xff0000, magazineSize: 8, reloadTime: 2.5, cost: 500, spread: 0.15, pelletsPerShot: 5, penetration: false },
            sniper: { name: 'SNIPER', damage: 100, fireRate: 1200, bulletSpeed: 80, bulletColor: 0x00ffff, magazineSize: 5, reloadTime: 3.0, cost: 800, spread: 0, penetration: true },
            plasma: { name: 'PLASMA', damage: 35, fireRate: 300, bulletSpeed: 50, bulletColor: 0xff00ff, magazineSize: 20, reloadTime: 2.0, cost: 1200, spread: 0, penetration: true }
        };

        const state = {
            hp: 100,
            maxHp: 100,
            gold: 0,
            level: 1,
            exp: 0,
            expToNext: 100,
            skillPoints: 0,
            wave: 1,
            enemiesRemaining: 0,
            enemiesToSpawn: 0,
            lastShot: 0,
            isPaused: true,
            isGameOver: false,
            canShoot: true,
            // Weapon stats
            currentWeapon: 'pistol',
            currentAmmo: 12,
            isReloading: false,
            ownedWeapons: ['pistol'],
            // Player stats
            kills: 0,
            critChance: 0,
            dodgeChance: 0,
            regenRate: 0,
            fireRateMult: 1.0,
            damageResist: 0,
            xpMult: 1.0,
            ammoEfficiency: 0,
            speedMult: 1.0
        };

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(CONFIG.colors.sky);
        scene.fog = new THREE.Fog(CONFIG.colors.sky, 10, 60); // Reduced fog distance for performance

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.y = 1.6; // Eye level

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Better quality, reasonable performance
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Lighting - Reduced for performance
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); // Increased ambient to compensate
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.6); // Reduced intensity
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        // Reduced shadow map size for performance
        dirLight.shadow.camera.left = -50;
        dirLight.shadow.camera.right = 50;
        dirLight.shadow.camera.top = 50;
        dirLight.shadow.camera.bottom = -50;
        dirLight.shadow.mapSize.width = 1024; // Reduced from 2048
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        // Controls
        const controls = new THREE.PointerLockControls(camera, document.body);

        // --- ASSETS GENERATION ---

        // Ground
        const groundGeo = new THREE.PlaneGeometry(400, 400);
        const groundMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.ground, roughness: 0.8 });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // City Generation - OPTIMIZED
        const buildings = [];
        const environmentObjects = [];
        const citySize = 8; // Reduced from 10 for better performance
        const blockSize = 20;
        const streetWidth = 15;
        let pointLightCount = 0;
        const MAX_POINT_LIGHTS = 8; // Limit point lights for performance

        function createCity() {
            const buildingColors = [0x222222, 0x1a0033, 0x001a33, 0x331a00];
            const neonColors = [0x00ffff, 0xff00ff, 0xff0000, 0x00ff00, 0xffff00];

            for (let x = -citySize; x <= citySize; x++) {
                for (let z = -citySize; z <= citySize; z++) {
                    // Don't build on start area
                    if (Math.abs(x) < 2 && Math.abs(z) < 2) continue;

                    // Random Height Building with varied colors
                    const height = Math.random() * 25 + 10;
                    const bGeo = new THREE.BoxGeometry(12, height, 12);
                    const buildingColor = buildingColors[Math.floor(Math.random() * buildingColors.length)];
                    const material = new THREE.MeshStandardMaterial({ color: buildingColor, roughness: 0.7 });
                    const building = new THREE.Mesh(bGeo, material);
                    const posX = x * (blockSize + streetWidth);
                    const posZ = z * (blockSize + streetWidth);
                    building.position.set(posX, height / 2, posZ);

                    // Only cast shadows for nearby buildings to improve performance
                    const distFromCenter = Math.sqrt(x * x + z * z);
                    if (distFromCenter < 5) {
                        building.castShadow = true;
                        building.receiveShadow = true;
                    }

                    scene.add(building);
                    buildings.push(building);

                    // Neon Edges with varied colors
                    const neonColor = neonColors[Math.floor(Math.random() * neonColors.length)];
                    const edgeMaterial = new THREE.LineBasicMaterial({ color: neonColor });
                    const edges = new THREE.EdgesGeometry(bGeo);
                    const line = new THREE.LineSegments(edges, edgeMaterial);
                    building.add(line);

                    // DRASTICALLY reduced point lights - only on very few buildings
                    if (Math.random() > 0.95 && pointLightCount < MAX_POINT_LIGHTS) {
                        const pointLight = new THREE.PointLight(neonColor, 1.5, 25); // Reduced intensity and range
                        pointLight.position.set(posX, height + 2, posZ);
                        scene.add(pointLight);
                        pointLightCount++;
                    }

                    // Fewer street lights
                    if (Math.random() > 0.92 && distFromCenter < 6) {
                        createStreetLight(posX + 10, posZ + 10);
                    }

                    // Fewer cars - only near center
                    if (Math.random() > 0.92 && distFromCenter > 3 && distFromCenter < 7) {
                        createCar(posX + (Math.random() - 0.5) * 15, posZ + (Math.random() - 0.5) * 15);
                    }
                }
            }
        }

        function createStreetLight(x, z) {
            // Pole
            const poleGeo = new THREE.CylinderGeometry(0.2, 0.2, 5);
            const poleMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const pole = new THREE.Mesh(poleGeo, poleMat);
            pole.position.set(x, 2.5, z);
            // Don't cast shadows for performance
            scene.add(pole);

            // Light
            const lightGeo = new THREE.SphereGeometry(0.3);
            const lightMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
            const light = new THREE.Mesh(lightGeo, lightMat);
            light.position.set(x, 5, z);
            scene.add(light);

            // No actual point light - use emissive material instead for performance
            environmentObjects.push(pole, light);
        }

        function createCar(x, z) {
            const carColors = [0x333333, 0x660000, 0x000066, 0x006600];
            const color = carColors[Math.floor(Math.random() * carColors.length)];

            const bodyGeo = new THREE.BoxGeometry(2, 1, 4);
            const carMat = new THREE.MeshStandardMaterial({ color: color, metalness: 0.6, roughness: 0.4 });
            const body = new THREE.Mesh(bodyGeo, carMat);
            body.position.set(x, 0.5, z);
            body.rotation.y = Math.random() * Math.PI * 2;
            // Don't cast shadows for performance
            scene.add(body);

            environmentObjects.push(body);
        }
        createCity();

        // Gun Model
        const gunGroup = new THREE.Group();
        const gunGeo = new THREE.BoxGeometry(0.15, 0.15, 0.6);
        const gunMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const gunMesh = new THREE.Mesh(gunGeo, gunMat);
        gunMesh.position.set(0.2, -0.2, -0.3);
        gunGroup.add(gunMesh);

        // Gun barrel glow
        const barrelGeo = new THREE.BoxGeometry(0.05, 0.05, 0.1);
        const barrelMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
        const barrel = new THREE.Mesh(barrelGeo, barrelMat);
        barrel.position.set(0.2, -0.2, -0.6);
        gunGroup.add(barrel);

        camera.add(gunGroup);
        scene.add(camera);

        // --- GAME ENTITIES ---

        let bullets = [];
        let zombies = [];
        let particles = [];
        let pickups = [];

        class Bullet {
            constructor(position, quaternion, weaponData, spread = 0) {
                const geo = new THREE.SphereGeometry(0.05);
                const mat = new THREE.MeshBasicMaterial({ color: weaponData.bulletColor });
                this.mesh = new THREE.Mesh(geo, mat);
                this.mesh.position.copy(position);
                this.mesh.quaternion.copy(quaternion);

                // Apply bullet spread
                if (spread > 0) {
                    this.mesh.rotateY((Math.random() - 0.5) * spread);
                    this.mesh.rotateX((Math.random() - 0.5) * spread);
                }

                this.speed = weaponData.bulletSpeed;
                this.damage = weaponData.damage;
                this.penetration = weaponData.penetration;
                this.alive = true;
                this.life = 3.0; // seconds
                this.hitEnemies = new Set(); // Track hit enemies for penetration

                // Start slightly ahead of camera
                this.mesh.translateZ(-0.5);

                scene.add(this.mesh);
            }

            update(dt) {
                this.mesh.translateZ(-this.speed * dt);
                this.life -= dt;
                if (this.life <= 0) this.kill();
            }

            kill() {
                this.alive = false;
                scene.remove(this.mesh);
                this.mesh.geometry.dispose();
            }
        }

        class Zombie {
            constructor(position, isBoss = false) {
                this.type = 'zombie';
                this.isBoss = isBoss;
                this.hp = (isBoss ? 300 : 50) + (state.wave * (isBoss ? 50 : 10));
                this.maxHp = this.hp;
                this.speed = (isBoss ? 3 : 4) + (state.wave * 0.2);
                this.damage = isBoss ? 25 : 10;
                this.expReward = isBoss ? 100 : 20;
                this.goldReward = isBoss ? 50 + state.wave * 5 : 10 + state.wave;

                const size = isBoss ? 1.5 : 1.0;
                const color = isBoss ? 0xff0000 : CONFIG.colors.zombie;

                // Create detailed zombie model
                this.mesh = new THREE.Group();

                // Legs - at bottom
                const legGeo = new THREE.BoxGeometry(0.2 * size, 0.6 * size, 0.2 * size);
                const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.8 });
                const leftLeg = new THREE.Mesh(legGeo, mat);
                leftLeg.position.set(-0.15 * size, 0.3 * size, 0);
                this.mesh.add(leftLeg);
                const rightLeg = new THREE.Mesh(legGeo, mat);
                rightLeg.position.set(0.15 * size, 0.3 * size, 0);
                this.mesh.add(rightLeg);

                // Torso - above legs
                const torsoGeo = new THREE.BoxGeometry(0.5 * size, 0.7 * size, 0.35 * size);
                const torso = new THREE.Mesh(torsoGeo, mat);
                torso.position.y = 0.95 * size;
                this.mesh.add(torso);

                // Head - on top of torso
                const headGeo = new THREE.BoxGeometry(0.35 * size, 0.35 * size, 0.35 * size);
                const head = new THREE.Mesh(headGeo, mat);
                head.position.y = 1.45 * size;
                this.mesh.add(head);

                // Eyes - Glowing on head
                const eyeGeo = new THREE.BoxGeometry(0.08 * size, 0.08 * size, 0.05 * size);
                const eyeColor = isBoss ? 0xffff00 : 0xff0000;
                const eyeMat = new THREE.MeshBasicMaterial({ color: eyeColor });
                const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
                leftEye.position.set(-0.09 * size, 1.47 * size, 0.18 * size);
                this.mesh.add(leftEye);
                const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
                rightEye.position.set(0.09 * size, 1.47 * size, 0.18 * size);
                this.mesh.add(rightEye);

                // Arms - at shoulder height, pointing down
                const armGeo = new THREE.BoxGeometry(0.12 * size, 0.5 * size, 0.12 * size);
                const leftArm = new THREE.Mesh(armGeo, mat);
                leftArm.position.set(-0.35 * size, 0.75 * size, 0.05 * size);
                leftArm.rotation.z = 0.15;  // Slight outward angle
                leftArm.rotation.x = 0.3;    // Point downward/forward
                this.mesh.add(leftArm);
                const rightArm = new THREE.Mesh(armGeo, mat);
                rightArm.position.set(0.35 * size, 0.75 * size, 0.05 * size);
                rightArm.rotation.z = -0.15; // Slight outward angle
                rightArm.rotation.x = 0.3;    // Point downward/forward
                this.mesh.add(rightArm);

                // Boss features
                if (isBoss) {
                    const crownGeo = new THREE.ConeGeometry(0.2 * size, 0.35 * size, 6);
                    const crownMat = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffaa00, emissiveIntensity: 0.5, metalness: 0.8 });
                    const crown = new THREE.Mesh(crownGeo, crownMat);
                    crown.position.set(0, 1.75 * size, 0);
                    this.mesh.add(crown);

                    // Boss aura
                    for (let i = 0; i < 3; i++) {
                        const auraGeo = new THREE.SphereGeometry(0.08);
                        const auraMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.6 });
                        const aura = new THREE.Mesh(auraGeo, auraMat);
                        const angle = (i / 3) * Math.PI * 2;
                        aura.position.set(Math.cos(angle) * 0.5, 1.0, Math.sin(angle) * 0.5);
                        this.mesh.add(aura);
                    }
                }

                this.mesh.position.copy(position);
                this.mesh.position.y = 0; // Start at ground level
                this.mesh.castShadow = true;
                scene.add(this.mesh);
                this.alive = true;
            }

            update(dt, playerPos) {
                if (!this.alive) return;

                // Move towards player
                const dir = new THREE.Vector3().subVectors(playerPos, this.mesh.position).normalize();
                dir.y = 0;

                this.mesh.position.add(dir.multiplyScalar(this.speed * dt));
                this.mesh.lookAt(playerPos.x, this.mesh.position.y, playerPos.z);

                // Slight walking bob
                this.mesh.children[0].position.y = 0.3 + Math.sin(Date.now() * 0.01) * 0.03; // left leg
                this.mesh.children[1].position.y = 0.3 + Math.sin(Date.now() * 0.01 + Math.PI) * 0.03; // right leg

                // Attack player
                const dist = this.mesh.position.distanceTo(playerPos);
                if (dist < 1.5) {
                    takeDamage(this.damage * dt);
                }
            }

            takeDamage(amount) {
                this.hp -= amount;
                // Flash effect on all children
                this.mesh.children.forEach(child => {
                    if (child.material && child.material.emissive) {
                        child.material.emissive.setHex(0xffffff);
                        setTimeout(() => {
                            if (this.alive && child.material.emissive) {
                                child.material.emissive.setHex(0x000000);
                            }
                        }, 50);
                    }
                });

                if (this.hp <= 0) this.die();
            }

            die() {
                this.alive = false;
                scene.remove(this.mesh);
                state.enemiesRemaining--;
                state.kills++;
                addExp(Math.floor(this.expReward * state.xpMult));
                addGold(this.goldReward);
                createParticles(this.mesh.position, this.isBoss ? 0xff0000 : 0x00ff00, this.isBoss ? 20 : 10);

                if (this.isBoss && Math.random() > 0.5) {
                    createPickup(this.mesh.position, 'ammo');
                }
            }
        }

        // New Enemy Types
        class Runner {
            constructor(position) {
                this.type = 'runner';
                this.hp = 30 + (state.wave * 5);
                this.maxHp = this.hp;
                this.speed = 8 + (state.wave * 0.3);
                this.damage = 5;
                this.expReward = 15;
                this.goldReward = 5 + state.wave;

                // Sleek runner design
                this.mesh = new THREE.Group();
                const mat = new THREE.MeshStandardMaterial({ color: 0xffff00, metalness: 0.4, roughness: 0.6 });

                // Legs at bottom
                const legGeo = new THREE.BoxGeometry(0.08, 0.4, 0.08);
                const leg1 = new THREE.Mesh(legGeo, mat);
                leg1.position.set(-0.12, 0.2, 0);
                this.mesh.add(leg1);
                const leg2 = new THREE.Mesh(legGeo, mat);
                leg2.position.set(0.12, 0.2, 0);
                this.mesh.add(leg2);

                // Aerodynamic body - above legs
                const bodyGeo = new THREE.ConeGeometry(0.25, 0.8, 4);
                const body = new THREE.Mesh(bodyGeo, mat);
                body.rotation.x = Math.PI / 2;
                body.position.y = 0.6;
                this.mesh.add(body);

                // Head - small and pointed at front
                const headGeo = new THREE.SphereGeometry(0.15, 8, 8);
                const head = new THREE.Mesh(headGeo, mat);
                head.position.set(0, 0.7, 0.35);
                this.mesh.add(head);

                // Glowing eye stripe
                const eyeGeo = new THREE.BoxGeometry(0.25, 0.05, 0.05);
                const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const eyes = new THREE.Mesh(eyeGeo, eyeMat);
                eyes.position.set(0, 0.7, 0.4);
                this.mesh.add(eyes);

                // Speed trail effect pieces (original positions were fine as they are relative to the body)
                for (let i = 0; i < 2; i++) {
                    const trailGeo = new THREE.BoxGeometry(0.15, 0.05, 0.3);
                    const trailMat = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.4 });
                    const trail = new THREE.Mesh(trailGeo, trailMat);
                    trail.position.set(i === 0 ? -0.15 : 0.15, 0.3, -0.3);
                    this.mesh.add(trail);
                }

                this.mesh.position.copy(position);
                this.mesh.position.y = 0; // Start at ground
                this.mesh.castShadow = true;
                scene.add(this.mesh);
                this.alive = true;
            }

            update(dt, playerPos) {
                if (!this.alive) return;
                const dir = new THREE.Vector3().subVectors(playerPos, this.mesh.position).normalize();
                dir.y = 0;
                this.mesh.position.add(dir.multiplyScalar(this.speed * dt));
                this.mesh.lookAt(playerPos.x, this.mesh.position.y, playerPos.z);

                // Fast leg animation
                this.mesh.children[0].position.y = 0.2 + Math.abs(Math.sin(Date.now() * 0.02)) * 0.08;
                this.mesh.children[1].position.y = 0.2 + Math.abs(Math.cos(Date.now() * 0.02)) * 0.08;

                const dist = this.mesh.position.distanceTo(playerPos);
                if (dist < 1.2) takeDamage(this.damage * dt);
            }

            takeDamage(amount) {
                this.hp -= amount;
                this.mesh.children.forEach(child => {
                    if (child.material && child.material.emissive) {
                        child.material.emissive.setHex(0xffffff);
                        setTimeout(() => { if (this.alive && child.material.emissive) child.material.emissive.setHex(0x000000); }, 50);
                    }
                });
                if (this.hp <= 0) this.die();
            }

            die() {
                this.alive = false;
                scene.remove(this.mesh);
                state.enemiesRemaining--;
                state.kills++;
                addExp(Math.floor(this.expReward * state.xpMult));
                addGold(this.goldReward);
                createParticles(this.mesh.position, 0xffff00, 5);
            }
        }

        class Tank {
            constructor(position) {
                this.type = 'tank';
                this.hp = 150 + (state.wave * 30);
                this.maxHp = this.hp;
                this.speed = 2 + (state.wave * 0.1);
                this.damage = 20;
                this.expReward = 40;
                this.goldReward = 20 + state.wave * 2;

                // Heavily armored tank design
                this.mesh = new THREE.Group();
                const mat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.8, roughness: 0.3 });
                const plateMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.9, roughness: 0.2 });

                // Legs - thick and at bottom
                const legGeo = new THREE.BoxGeometry(0.25, 0.5, 0.25);
                const leftLeg = new THREE.Mesh(legGeo, mat);
                leftLeg.position.set(-0.3, 0.25, 0);
                this.mesh.add(leftLeg);
                const rightLeg = new THREE.Mesh(legGeo, mat);
                rightLeg.position.set(0.3, 0.25, 0);
                this.mesh.add(rightLeg);

                // Bottom armor plate
                const bottomPlate = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.15, 0.75), plateMat);
                bottomPlate.position.y = 0.55;
                this.mesh.add(bottomPlate);

                // Main body - large and wide
                const bodyGeo = new THREE.BoxGeometry(0.9, 0.9, 0.7);
                const body = new THREE.Mesh(bodyGeo, mat);
                body.position.y = 1.1;
                this.mesh.add(body);

                // Top armor plate
                const topPlate = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.15, 0.75), plateMat);
                topPlate.position.y = 1.6;
                this.mesh.add(topPlate);

                // Head/turret
                const headGeo = new THREE.CylinderGeometry(0.25, 0.3, 0.35, 8);
                const head = new THREE.Mesh(headGeo, mat);
                head.position.y = 1.85;
                this.mesh.add(head);

                // Glowing red eyes
                const eyeGeo = new THREE.CylinderGeometry(0.06, 0.06, 0.08, 6);
                const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
                leftEye.position.set(-0.1, 1.85, 0.25);
                leftEye.rotation.x = Math.PI / 2;
                this.mesh.add(leftEye);
                const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
                rightEye.position.set(0.1, 1.85, 0.25);
                rightEye.rotation.x = Math.PI / 2;
                this.mesh.add(rightEye);

                // Shoulder armor
                const shoulderGeo = new THREE.BoxGeometry(0.25, 0.35, 0.25);
                const leftShoulder = new THREE.Mesh(shoulderGeo, plateMat);
                leftShoulder.position.set(-0.6, 1.2, 0);
                this.mesh.add(leftShoulder);
                const rightShoulder = new THREE.Mesh(shoulderGeo, plateMat);
                rightShoulder.position.set(0.6, 1.2, 0);
                this.mesh.add(rightShoulder);

                this.mesh.position.copy(position);
                this.mesh.position.y = 0; // Ground level
                this.mesh.castShadow = true;
                scene.add(this.mesh);
                this.alive = true;
            }

            update(dt, playerPos) {
                if (!this.alive) return;
                const dir = new THREE.Vector3().subVectors(playerPos, this.mesh.position).normalize();
                dir.y = 0;
                this.mesh.position.add(dir.multiplyScalar(this.speed * dt));
                this.mesh.lookAt(playerPos.x, this.mesh.position.y, playerPos.z);

                // Slight stomp
                this.mesh.children[0].position.y = 0.25 + Math.sin(Date.now() * 0.005) * 0.02; // left leg
                this.mesh.children[1].position.y = 0.25 + Math.cos(Date.now() * 0.005) * 0.02; // right leg

                const dist = this.mesh.position.distanceTo(playerPos);
                if (dist < 1.8) takeDamage(this.damage * dt);
            }

            takeDamage(amount) {
                this.hp -= amount * 0.7;
                this.mesh.children.forEach(child => {
                    if (child.material && child.material.emissive) {
                        child.material.emissive.setHex(0xff0000);
                        setTimeout(() => { if (this.alive && child.material.emissive) child.material.emissive.setHex(0x000000); }, 50);
                    }
                });
                if (this.hp <= 0) this.die();
            }

            die() {
                this.alive = false;
                scene.remove(this.mesh);
                state.enemiesRemaining--;
                state.kills++;
                addExp(Math.floor(this.expReward * state.xpMult));
                addGold(this.goldReward);
                createParticles(this.mesh.position, 0x666666, 15);
                if (Math.random() > 0.7) createPickup(this.mesh.position, 'health');
            }
        }

        class Exploder {
            constructor(position) {
                this.type = 'exploder';
                this.hp = 40 + (state.wave * 8);
                this.maxHp = this.hp;
                this.speed = 6 + (state.wave * 0.25);
                this.damage = 40;
                this.explosionRadius = 5;
                this.expReward = 25;
                this.goldReward = 15 + state.wave;

                // Dangerous spiked sphere design
                this.mesh = new THREE.Group();

                // Core sphere with glowing effect
                const coreGeo = new THREE.SphereGeometry(0.4, 12, 12);
                const coreMat = new THREE.MeshStandardMaterial({
                    color: 0xff6600,
                    emissive: 0xff3300,
                    emissiveIntensity: 0.8,
                    roughness: 0.3,
                    metalness: 0.2
                });
                const core = new THREE.Mesh(coreGeo, coreMat);
                this.mesh.add(core);
                this.coreMaterial = coreMat; // Store reference for pulsing

                // Inner glowing core
                const innerGeo = new THREE.SphereGeometry(0.25, 8, 8);
                const innerMat = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.7 });
                const innerCore = new THREE.Mesh(innerGeo, innerMat);
                this.mesh.add(innerCore);

                // Spikes pointing outward
                const spikeGeo = new THREE.ConeGeometry(0.1, 0.4, 4);
                const spikeMat = new THREE.MeshStandardMaterial({ color: 0x331100, metalness: 0.7 });

                // Create spikes in multiple directions
                const spikePositions = [
                    [0, 1, 0], [0, -1, 0], [1, 0, 0], [-1, 0, 0], [0, 0, 1], [0, 0, -1],
                    [0.7, 0.7, 0], [-0.7, 0.7, 0], [0.7, -0.7, 0], [-0.7, -0.7, 0],
                    [0, 0.7, 0.7], [0, -0.7, 0.7], [0, 0.7, -0.7], [0, -0.7, -0.7]
                ];

                spikePositions.forEach(pos => {
                    const spike = new THREE.Mesh(spikeGeo, spikeMat);
                    const dir = new THREE.Vector3(pos[0], pos[1], pos[2]).normalize();
                    spike.position.copy(dir.multiplyScalar(0.4));
                    spike.lookAt(dir.multiplyScalar(2));
                    this.mesh.add(spike);
                });

                // Energy rings
                for (let i = 0; i < 2; i++) {
                    const ringGeo = new THREE.TorusGeometry(0.5 + i * 0.15, 0.03, 8, 16);
                    const ringMat = new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.4 });
                    const ring = new THREE.Mesh(ringGeo, ringMat);
                    ring.rotation.x = Math.PI / 2 + (i * 0.3);
                    ring.rotation.y = i * 0.5;
                    this.mesh.add(ring);
                }

                this.mesh.position.copy(position);
                this.mesh.position.y = 0.6;
                this.mesh.castShadow = true;
                scene.add(this.mesh);
                this.alive = true;
                this.pulseTime = 0;
            }

            update(dt, playerPos) {
                if (!this.alive) return;

                // Intense pulsing effect
                this.pulseTime += dt * 5;
                this.coreMaterial.emissiveIntensity = 0.5 + Math.sin(this.pulseTime) * 0.4;

                // Rotate for menacing effect
                this.mesh.rotation.y += dt * 2;
                this.mesh.rotation.x = Math.sin(this.pulseTime * 0.5) * 0.2;

                const dir = new THREE.Vector3().subVectors(playerPos, this.mesh.position).normalize();
                dir.y = 0;
                this.mesh.position.add(dir.multiplyScalar(this.speed * dt));

                const dist = this.mesh.position.distanceTo(playerPos);
                if (dist < 2.5) this.explode(playerPos);
            }

            takeDamage(amount) {
                this.hp -= amount;
                if (this.hp <= 0) this.explode(camera.position);
            }

            explode(playerPos) {
                if (!this.alive) return;
                this.alive = false;

                const dist = this.mesh.position.distanceTo(playerPos);
                if (dist < this.explosionRadius) {
                    takeDamage(this.damage * (1 - dist / this.explosionRadius));
                }

                createParticles(this.mesh.position, 0xff6600, 25);
                scene.remove(this.mesh);
                state.enemiesRemaining--;
                state.kills++;
                addExp(Math.floor(this.expReward * state.xpMult));
                addGold(this.goldReward);
            }

            die() {
                this.explode(camera.position);
            }
        }

        function createParticles(pos, color, count) {
            // Limit total particles for performance
            if (particles.length > 100) return;

            const actualCount = Math.min(count, 15); // Cap individual particle bursts
            for (let i = 0; i < actualCount; i++) {
                const geo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                const mat = new THREE.MeshBasicMaterial({ color: color });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                mesh.position.x += (Math.random() - 0.5);
                mesh.position.y += (Math.random() - 0.5);
                mesh.position.z += (Math.random() - 0.5);

                const vel = new THREE.Vector3((Math.random() - 0.5) * 5, Math.random() * 5, (Math.random() - 0.5) * 5);

                particles.push({ mesh, vel, life: 1.0 });
                scene.add(mesh);
            }
        }

        // Pickup System
        function createPickup(pos, type) {
            const geo = type === 'health' ? new THREE.SphereGeometry(0.3) : new THREE.BoxGeometry(0.4, 0.4, 0.4);
            const color = type === 'health' ? 0x00ff00 : 0xffaa00;
            const mat = new THREE.MeshBasicMaterial({ color: color });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(pos);
            mesh.position.y = 0.5;
            scene.add(mesh);
            pickups.push({ mesh, type, bobTime: 0 });
        }

        // --- GAME LOGIC ---

        // Input
        const moveState = { forward: false, backward: false, left: false, right: false, jump: false };
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let canJump = false;

        document.addEventListener('keydown', (event) => {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveState.forward = true; break;
                case 'ArrowLeft': case 'KeyA': moveState.left = true; break;
                case 'ArrowDown': case 'KeyS': moveState.backward = true; break;
                case 'ArrowRight': case 'KeyD': moveState.right = true; break;
                case 'Space': if (canJump) velocity.y = CONFIG.playerJump; canJump = false; break;
                case 'KeyB': toggleModal('shop-modal'); break;
                case 'KeyK': toggleModal('skill-modal'); break;
                case 'KeyR': reloadWeapon(); break;
                case 'Digit1': switchWeapon('pistol'); break;
                case 'Digit2': switchWeapon('smg'); break;
                case 'Digit3': switchWeapon('shotgun'); break;
                case 'Digit4': switchWeapon('sniper'); break;
                case 'Digit5': switchWeapon('plasma'); break;
            }
        });

        document.addEventListener('keyup', (event) => {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveState.forward = false; break;
                case 'ArrowLeft': case 'KeyA': moveState.left = false; break;
                case 'ArrowDown': case 'KeyS': moveState.backward = false; break;
                case 'ArrowRight': case 'KeyD': moveState.right = false; break;
            }
        });

        document.addEventListener('mousedown', () => {
            if (state.isPaused || !state.canShoot || state.isReloading) return;
            const weapon = WEAPONS[state.currentWeapon];
            const now = Date.now();
            const fireRate = weapon.fireRate / state.fireRateMult;

            if (now - state.lastShot > fireRate && state.currentAmmo > 0) {
                shoot();
                state.lastShot = now;
            }
        });

        function switchWeapon(weaponId) {
            if (state.isPaused || !state.ownedWeapons.includes(weaponId)) return;
            state.currentWeapon = weaponId;
            const weapon = WEAPONS[weaponId];
            state.currentAmmo = weapon.magazineSize;
            updateHUD();
            showNotification(`Switched to ${weapon.name}`);
        }

        function reloadWeapon() {
            if (state.isPaused || state.isReloading) return;
            const weapon = WEAPONS[state.currentWeapon];
            if (state.currentAmmo >= weapon.magazineSize) return;

            state.isReloading = true;
            state.canShoot = false;
            showNotification('Reloading...');

            setTimeout(() => {
                state.currentAmmo = weapon.magazineSize;
                state.isReloading = false;
                state.canShoot = true;
                updateHUD();
            }, weapon.reloadTime * 1000);
        }

        function shoot() {
            const weapon = WEAPONS[state.currentWeapon];

            // Consume ammo (with efficiency chance to not consume)
            if (Math.random() > state.ammoEfficiency / 100) {
                state.currentAmmo--;
            }

            // Recoil
            gunGroup.position.z = 0.2;

            // Shotgun shoots multiple pellets
            const pelletsPerShot = weapon.pelletsPerShot || 1;
            for (let i = 0; i < pelletsPerShot; i++) {
                bullets.push(new Bullet(camera.position, camera.quaternion, weapon, weapon.spread));
            }

            updateHUD();

            // Auto-reload when empty
            if (state.currentAmmo <= 0) {
                reloadWeapon();
            }
        }

        // Wave Management
        function startWave() {
            state.enemiesToSpawn = 3 + Math.floor(state.wave * 1.5);
            state.enemiesRemaining = state.enemiesToSpawn;

            // Boss wave every 5 waves
            const isBossWave = state.wave % 5 === 0;
            if (isBossWave) {
                showNotification(`BOSS WAVE ${state.wave}!`);
            }

            const spawnInterval = setInterval(() => {
                if (state.isPaused) return;
                if (state.enemiesToSpawn <= 0) {
                    clearInterval(spawnInterval);
                    return;
                }

                // Spawn position
                const angle = Math.random() * Math.PI * 2;
                const dist = 30 + Math.random() * 20;
                const x = camera.position.x + Math.cos(angle) * dist;
                const z = camera.position.z + Math.sin(angle) * dist;
                const spawnPos = new THREE.Vector3(x, 0, z);

                // Determine enemy type based on wave
                if (isBossWave && state.enemiesToSpawn === Math.floor(3 + state.wave * 1.5)) {
                    // Spawn boss at beginning of boss wave
                    zombies.push(new Zombie(spawnPos, true));
                } else {
                    const rand = Math.random();
                    if (state.wave < 3) {
                        // Early waves: mostly zombies
                        zombies.push(new Zombie(spawnPos));
                    } else if (state.wave < 6) {
                        // Mid waves: add runners
                        if (rand < 0.7) zombies.push(new Zombie(spawnPos));
                        else zombies.push(new Runner(spawnPos));
                    } else if (state.wave < 10) {
                        // Later waves: add tanks and exploders
                        if (rand < 0.4) zombies.push(new Zombie(spawnPos));
                        else if (rand < 0.7) zombies.push(new Runner(spawnPos));
                        else if (rand < 0.85) zombies.push(new Tank(spawnPos));
                        else zombies.push(new Exploder(spawnPos));
                    } else {
                        // Late game: all enemy types
                        if (rand < 0.3) zombies.push(new Zombie(spawnPos));
                        else if (rand < 0.55) zombies.push(new Runner(spawnPos));
                        else if (rand < 0.75) zombies.push(new Tank(spawnPos));
                        else zombies.push(new Exploder(spawnPos));
                    }
                }
                state.enemiesToSpawn--;
            }, 1000);
        }

        // RPG Functions
        function addExp(amount) {
            state.exp += amount;
            if (state.exp >= state.expToNext) {
                state.level++;
                state.exp -= state.expToNext;
                state.expToNext = Math.floor(state.expToNext * 1.2);
                state.skillPoints++;
                state.hp = state.maxHp; // Heal on level up
                showNotification("LEVEL UP! Skill Point Gained!");
            }
            updateHUD();
        }

        function addGold(amount) {
            state.gold += amount;
            updateHUD();
        }

        function takeDamage(amount) {
            // Apply dodge chance
            if (Math.random() * 100 < state.dodgeChance) {
                showNotification('DODGED!');
                return;
            }

            // Apply damage resistance
            const actualDamage = amount * (1 - state.damageResist / 100);
            state.hp -= actualDamage;

            // Flash red
            const overlay = document.getElementById('damage-overlay');
            overlay.style.opacity = 0.6;
            setTimeout(() => { overlay.style.opacity = 0; }, 300);

            if (state.hp <= 0 && !state.isGameOver) {
                state.isGameOver = true;
                controls.unlock();
                alert(`GAME OVER\nWave Reached: ${state.wave}\nKills: ${state.kills}\nRefresh to restart.`);
                location.reload();
            }
            updateHUD();
        }

        // Shop & Skills
        function toggleModal(id) {
            const modal = document.getElementById(id);
            if (modal.style.display === 'block') {
                modal.style.display = 'none';
                controls.lock();
            } else {
                // Close others
                document.querySelectorAll('.modal').forEach(m => m.style.display = 'none');
                modal.style.display = 'block';
                controls.unlock();
                updateMenus();
            }
        }

        function updateMenus() {
            document.getElementById('shop-gold').innerText = state.gold;
            document.getElementById('skill-points').innerText = state.skillPoints;

            // Disable shop items based on gold
            document.getElementById('btn-buy-potion').disabled = state.gold < 50;
            document.getElementById('btn-buy-ammo').disabled = state.gold < 30;
            document.getElementById('btn-buy-smg').disabled = state.gold < 300 || state.ownedWeapons.includes('smg');
            document.getElementById('btn-buy-shotgun').disabled = state.gold < 500 || state.ownedWeapons.includes('shotgun');
            document.getElementById('btn-buy-sniper').disabled = state.gold < 800 || state.ownedWeapons.includes('sniper');
            document.getElementById('btn-buy-plasma').disabled = state.gold < 1200 || state.ownedWeapons.includes('plasma');
        }

        window.buyPotion = () => {
            if (state.gold >= 50) {
                state.gold -= 50;
                state.hp = Math.min(state.hp + 50, state.maxHp);
                showNotification('+50 HP');
                updateHUD();
                updateMenus();
            }
        };

        window.buyAmmo = () => {
            if (state.gold >= 30) {
                state.gold -= 30;
                const weapon = WEAPONS[state.currentWeapon];
                state.currentAmmo = weapon.magazineSize;
                showNotification('Ammo Refilled!');
                updateHUD();
                updateMenus();
            }
        };

        window.buyWeapon = (weaponId) => {
            const weapon = WEAPONS[weaponId];
            if (state.gold >= weapon.cost && !state.ownedWeapons.includes(weaponId)) {
                state.gold -= weapon.cost;
                state.ownedWeapons.push(weaponId);
                showNotification(`${weapon.name} Purchased!`);
                updateMenus();
                updateHUD();
            }
        };

        window.buyFireRate = () => {
            if (state.gold >= 200) {
                state.gold -= 200;
                state.fireRate = Math.max(100, state.fireRate * 0.9);
                updateHUD();
                updateMenus();
            }
        };

        window.upgradeSkill = (type) => {
            if (state.skillPoints > 0) {
                state.skillPoints--;

                switch (type) {
                    case 'damage':
                        WEAPONS[state.currentWeapon].damage *= 1.2;
                        showNotification('Damage Increased!');
                        break;
                    case 'health':
                        state.maxHp += 20;
                        state.hp += 20;
                        showNotification('Max HP +20!');
                        break;
                    case 'speed':
                        state.speedMult += 0.05;
                        showNotification('Speed Increased!');
                        break;
                    case 'critChance':
                        state.critChance += 10;
                        showNotification('Crit Chance +10%!');
                        break;
                    case 'dodge':
                        state.dodgeChance += 8;
                        showNotification('Dodge +8%!');
                        break;
                    case 'regen':
                        state.regenRate += 1;
                        showNotification('Regen +1 HP/s!');
                        break;
                    case 'fireRate':
                        state.fireRateMult += 0.15;
                        showNotification('Fire Rate +15%!');
                        break;
                    case 'resistance':
                        state.damageResist += 5;
                        showNotification('Damage Resist +5%!');
                        break;
                    case 'xpBoost':
                        state.xpMult += 0.2;
                        showNotification('XP Gain +20%!');
                        break;
                    case 'ammoEfficiency':
                        state.ammoEfficiency += 20;
                        showNotification('Ammo Efficiency +20%!');
                        break;
                }

                updateHUD();
                updateMenus();
            }
        };

        function showNotification(text) {
            const el = document.getElementById('notification-area');
            el.innerText = text;
            el.style.opacity = 1;
            setTimeout(() => el.style.opacity = 0, 3000);
        }

        function updateHUD() {
            document.getElementById('hud-level').innerText = state.level;
            document.getElementById('hud-gold').innerText = state.gold;
            document.getElementById('hud-sp').innerText = state.skillPoints;

            const hpPct = (state.hp / state.maxHp) * 100;
            document.getElementById('hud-hp-fill').style.width = hpPct + '%';
            document.getElementById('hud-hp-text').innerText = Math.floor(state.hp) + '/' + state.maxHp;

            const expPct = (state.exp / state.expToNext) * 100;
            document.getElementById('hud-exp-fill').style.width = expPct + '%';

            document.getElementById('wave-panel').innerText = "WAVE " + state.wave;

            // Weapon info
            const weapon = WEAPONS[state.currentWeapon];
            document.getElementById('hud-weapon').innerText = weapon.name;
            document.getElementById('hud-ammo').innerText = state.currentAmmo + '/' + weapon.magazineSize;
            document.getElementById('hud-kills').innerText = state.kills;
        }

        // --- MAIN LOOP ---

        controls.addEventListener('lock', () => {
            state.isPaused = false;
            document.getElementById('start-screen').style.display = 'none';
        });

        controls.addEventListener('unlock', () => {
            // Only pause if not game over and not in a menu
            const anyModalOpen = document.querySelector('.modal[style*="block"]');
            if (!state.isGameOver && !anyModalOpen) {
                // Just unlocked via ESC without opening menu
                state.isPaused = true;
                // Optional: Show "Paused" text
            }
            if (anyModalOpen) state.isPaused = true;
        });

        window.startGame = () => {
            controls.lock();
            startWave();
        };

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            if (state.isPaused || state.isGameOver) return;

            const delta = Math.min(clock.getDelta(), 0.1); // Cap delta to prevent huge jumps

            // 1. Physics & Movement
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;
            velocity.y -= CONFIG.gravity * delta; // Gravity

            direction.z = Number(moveState.forward) - Number(moveState.backward);
            direction.x = Number(moveState.right) - Number(moveState.left);
            direction.normalize();

            if (moveState.forward || moveState.backward) velocity.z -= direction.z * 400.0 * delta * state.speedMult;
            if (moveState.left || moveState.right) velocity.x -= direction.x * 400.0 * delta * state.speedMult;

            controls.moveRight(-velocity.x * delta);
            controls.moveForward(-velocity.z * delta);

            camera.position.y += velocity.y * delta;

            // Ground Collision
            if (camera.position.y < 1.6) {
                velocity.y = 0;
                camera.position.y = 1.6;
                canJump = true;
            }

            // Building Collision - OPTIMIZED with spatial awareness
            // Only check buildings near the player
            const playerGridX = Math.floor(camera.position.x / (blockSize + streetWidth));
            const playerGridZ = Math.floor(camera.position.z / (blockSize + streetWidth));
            const checkRadius = 2; // Only check nearby grid cells

            for (let offsetX = -checkRadius; offsetX <= checkRadius; offsetX++) {
                for (let offsetZ = -checkRadius; offsetZ <= checkRadius; offsetZ++) {
                    const gridX = playerGridX + offsetX;
                    const gridZ = playerGridZ + offsetZ;

                    // Skip if outside city bounds
                    if (Math.abs(gridX) > citySize || Math.abs(gridZ) > citySize) continue;
                    if (Math.abs(gridX) < 2 && Math.abs(gridZ) < 2) continue;

                    // Calculate building index (approximate)
                    const buildingIndex = (gridX + citySize) * (citySize * 2 + 1) + (gridZ + citySize);
                    const b = buildings[buildingIndex];

                    if (b) {
                        const box = new THREE.Box3().setFromObject(b);
                        const playerPos = camera.position.clone();
                        playerPos.y = b.position.y;
                        box.expandByScalar(0.5);

                        if (box.containsPoint(playerPos)) {
                            const dir = new THREE.Vector3().subVectors(camera.position, b.position).normalize();
                            dir.y = 0;
                            controls.moveRight(dir.x * 0.2);
                            controls.moveForward(dir.z * 0.2);
                        }
                    }
                }
            }

            // 2. Gun Animation
            gunGroup.position.z += (0 - gunGroup.position.z) * 10 * delta; // Return to pos

            // 3. Health Regeneration
            if (state.regenRate > 0) {
                state.hp = Math.min(state.hp + state.regenRate * delta, state.maxHp);
                updateHUD();
            }

            // 4. Bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                let b = bullets[i];
                b.update(delta);

                // Zombie Collision - Check all enemy types with larger radius for headshots
                for (let j = zombies.length - 1; j >= 0; j--) {
                    let z = zombies[j];
                    // Increased radius to 1.5 to allow hitting head and all body parts
                    if (z.alive && b.alive && !b.hitEnemies.has(z) && b.mesh.position.distanceTo(z.mesh.position) < 1.5) {
                        // Apply critical hit
                        let damage = b.damage;
                        if (Math.random() * 100 < state.critChance) {
                            damage *= 2;
                            showNotification('CRITICAL HIT!');
                        }

                        z.takeDamage(damage);

                        // Penetration: mark enemy as hit but don't kill bullet
                        if (b.penetration) {
                            b.hitEnemies.add(z);
                        } else {
                            b.kill();
                        }

                        createParticles(b.mesh.position, 0xffff00, 3);
                        if (!b.penetration) break;
                    }
                }

                if (!b.alive) bullets.splice(i, 1);
            }

            // 5. Zombies
            if (zombies.length === 0 && state.enemiesToSpawn === 0) {
                // Wave Complete
                state.wave++;
                showNotification(`WAVE ${state.wave} STARTED`);
                startWave();
                // Random pickup spawn on wave complete
                if (Math.random() > 0.6) {
                    createPickup(camera.position.clone().add(new THREE.Vector3(5, 0, 5)), Math.random() > 0.5 ? 'health' : 'ammo');
                }
            }

            for (let i = zombies.length - 1; i >= 0; i--) {
                let z = zombies[i];
                z.update(delta, camera.position);
                if (!z.alive) zombies.splice(i, 1);
            }

            // 6. Pickups - bobbing and collection
            for (let i = pickups.length - 1; i >= 0; i--) {
                let p = pickups[i];
                p.bobTime += delta;
                p.mesh.position.y = 0.5 + Math.sin(p.bobTime * 3) * 0.2;
                p.mesh.rotation.y += delta * 2;

                // Check collection
                const dist = camera.position.distanceTo(p.mesh.position);
                if (dist < 2) {
                    if (p.type === 'health') {
                        state.hp = Math.min(state.hp + 30, state.maxHp);
                        showNotification('+30 HP');
                    } else if (p.type === 'ammo') {
                        const weapon = WEAPONS[state.currentWeapon];
                        state.currentAmmo = weapon.magazineSize;
                        showNotification('Ammo Refilled!');
                    }
                    scene.remove(p.mesh);
                    pickups.splice(i, 1);
                    updateHUD();
                }
            }

            // 7. Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.life -= delta;
                p.mesh.position.add(p.vel.clone().multiplyScalar(delta));
                p.vel.y -= 9.8 * delta; // gravity
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>

</html>